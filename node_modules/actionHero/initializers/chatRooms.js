var chatRooms = function(api, next){

  api.chatRoom = {};

  if(api.redis.enable === false){
    api.chatRoom.rooms = {};
  }else{
    api.chatRoom.redisRoomPrefix = "actionHero:roomMembers:";
    api.chatRoom.chatChannel = "actionHero:say:" + api.configData.redis.DB;
  }

  ////////////////////////////////////////////////////////////////////////////
  // broadcast a message to all connections in a room
  api.chatRoom.socketRoomBroadcast = function(connection, message, fromQueue){
    if(fromQueue == null){fromQueue = false;}
    if(connection == null){ connection = {}; }
    if(connection.room == null){ connection.room = api.configData.general.defaultChatRoom; }
    if(connection.id == null){ connection.id = 0; }
    if(connection.params != null && connection.params.roomMatchKey != null){ connection.roomMatchKey = connection.params.roomMatchKey; }
    if(connection.params != null && connection.params.roomMatchValue != null){ connection.roomMatchValue = connection.params.roomMatchValue; }
    if(api.redis.enable === true && fromQueue == false){ 
	var messagePayload = {message: message, room: connection.room, params:connection.params};

      
		// find users in rooms
		//for each user in res
		//retrieve their hash
		//know if they are online , if online ,do nothing , else send notification

		api.redis.client.keys("actionHero:roomMembers:"+connection.room+":*",function(err,res){
			for (var i=0; i<res.length; i++) {
				api.redis.client.HGETALL(res[i],function(error,result){
					if (result.online_status == "false") {
							var apns = require("apns"), options, conn, notification;

							options = {
							   keyFile : "certs/sskey.pem",
							   certFile : "certs/sscert.pem",
							   gateway : "gateway.sandbox.push.apple.com",
							   debug : true
							};

							conn = new apns.Connection(options);

							notification = new apns.Notification();
							notification.device = new apns.Device(result.device_token);
							notification.sound = "dong.aiff";
							notification.payload = {"aps" : {"alert":"test!"}};
							notification.alert = connection.params.fb_name + ": " + message;
							conn.sendNotification(notification);
					};					
				});
			}

			
		});
	  api.redis.client.lpush("actionHero:room:"+connection.room, JSON.stringify(messagePayload));
       api.redis.client.publish(api.chatRoom.chatChannel, JSON.stringify(messagePayload));
    }

      api.stats.increment("chatRooom:messagesSent");
     // var messagePayload = {message: message, room: connection.room, from: connection.id, params:connection.params, context: "user", sentAt: new Date().getTime() };
      for(var i in api.connections.connections){
        var thisConnection = api.connections.connections[i];
        if(thisConnection.room == connection.room || thisConnection.additionalListeningRooms.indexOf(connection.room) > -1){
          if(connection == null || thisConnection.id != connection.id){
            var matched = false;
            if(connection.roomMatchKey == null){
              matched = true;
            }else if(thisConnection[connection.roomMatchKey] == connection.roomMatchValue){
                matched = true;
            }
            if(matched == true){
              thisConnection.sendMessage(messagePayload, 'say');
            }
          }
        }
      
    
	}
  }
  
  ////////////////////////////////////////////////////////////////////////////
  // status for a room
  api.chatRoom.socketRoomStatus = function(room, next){
    if(api.redis.enable === true){
      var key = api.chatRoom.redisRoomPrefix + room;
      api.redis.client.lrange(key, 0, -1, function(err, members){
        next(null, {
          room: room,
          members: members,
          membersCount: members.length
        });
      });
    }else{
      if(api.chatRoom.rooms[room] != null){
        next(null, {
          room: room,
          members: api.chatRoom.rooms[room],
          membersCount: api.chatRoom.rooms[room].length
        });
      }else{
        next(null, {
          room: room,
          members: null,
          membersCount: 0
        });
      }
    }
  }

  api.chatRoom.roomAddMember = function(connection, next){
    var room = connection.room;
    var name = connection.id;
	var params = connection.params;
    api.chatRoom.socketRoomStatus(room, function(err, roomStatus)
	{
      	var found = false;

      	for(var i in roomStatus.members)
		{
        if (name == roomStatus.members[i]){ found = true; break; }
  		}

    	if(found == false)
		{
        api.stats.increment("chatRooom:roomMembers:" + connection.room);
        if(api.redis.enable === true){
	      if(room == "defaultRoom") // if its the default room , dont bother
		  {
		    var key = api.chatRoom.redisRoomPrefix + connection.room;
	          api.redis.client.rpush(key, name , function(){
	            if(typeof next == "function"){ next(null, true) }
	          });
	      }
		  else
		  { 
			 //serve up the last 20 messages
			 var roomKey = "actionHero:room:" + connection.room  ;
			 api.redis.client.lrange(roomKey,0,20,function(err,result){
				api.socketServer.prepareSocketMessage(connection, {context: "response", messages:result });
				});
			 api.chatRoom.updateRoomMemberOnlineStatus(connection, true);
	      }
        }else{
          if(api.chatRoom.rooms[room] == null){
            api.chatRoom.rooms[room] = [];
          }
          api.chatRoom.rooms[room].push(name);
          if(typeof next == "function"){ next(null, true) }
        }
      }else{
        if(typeof next == "function"){ next(new Error("Connection already in this room"), false) }
      }
    });
  }
  	api.chatRoom.leaveRoom = function(room, connection, next)
	{
    	var name = connection.id;
    	api.stats.increment("chatRooom:roomMembers:" + connection.room, -1);
      	var key = api.chatRoom.redisRoomPrefix + connection.room;
      	api.redis.client.lrem(key, 1, name, function(){
	    
		if(room != "defaultRoom")
		{ 
		
			// if its the default room , dont bother
        	// remove user hash from room
			api.chatRoom.removeUserHashFromRoom(room,connection);
			
			//if theres no one in the room remove all its messages
			api.redis.client.keys("actionHero:roomMembers:"+room+":*",function(err,res)
			{
				if(res.length == 0)
				{
					api.redis.client.del("actionHero:room:"+room); // delete all messages
				}
			});
		}
        if(typeof next == "function"){ next(null, true) }
      });
 
	}
// doesnt actually remove member, just sets their online status to false
  api.chatRoom.roomRemoveMember = function(connection, next){
    var room = connection.room;
    var name = connection.id;
    api.stats.increment("chatRooom:roomMembers:" + connection.room, -1);
    if(api.redis.enable === true){
      var key = api.chatRoom.redisRoomPrefix + connection.room;
      api.redis.client.lrem(key, 1, name, function(){
	      if(room != "defaultRoom") // if its the default room , dont bother
		api.chatRoom.updateRoomMemberOnlineStatus(connection, false);
        if(typeof next == "function"){ next(null, true) }
      });
    }else{
      for(var i in api.chatRoom.rooms){
        if(i == room){
          var rList = api.chatRoom.rooms[i];
          for(var j in rList){
            if(rList[j] == name){
              rList.splice(j,1);
              break;
            }
          }
          break;
        }
      }
      if(typeof next == "function"){ next(null, true) }
    }
  }

	//deprecated for now
  	api.chatRoom.announceMember = function(connection, direction)
	{
	var message;
	var returnFunction = function(){if(typeof next == "function"){ next(null, true)}};
	var key = api.chatRoom.redisRoomPrefix + connection.room + ":" + params.fb_name + ":status";
	api.redis.client.set(key,direction,returnFunction);
    }

  	api.chatRoom.updateRoomMemberOnlineStatus = function(connection, direction)
	{
	var key = api.chatRoom.redisRoomPrefix + connection.room + ":" + connection.params.fb_name;
	api.redis.client.hmset(key,"fb_name",connection.params.fb_name,"device_token",connection.params.device_token,"online_status",direction);
    }

  	api.chatRoom.removeUserHashFromRoom = function(room, connection)
	{
	var key = api.chatRoom.redisRoomPrefix + room + ":" + connection.params.fb_name;
	api.redis.client.del(key)
    }

  ////////////////////////////////////////////////////////////////////////////
  // register for messages
  if(api.redis.enable === true){
    api.redis.registerChannel(api.chatRoom.chatChannel, function(channel, message){
      message = JSON.parse(message);
      api.chatRoom.socketRoomBroadcast(message.connection, message.message, true);
    });
  }

  next();
}

/////////////////////////////////////////////////////////////////////
// exports
exports.chatRooms = chatRooms;